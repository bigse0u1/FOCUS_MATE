<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FocusMate Vision</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0; background: #0e0e0e; color: #eee;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    /* ì¢Œ: ì¹´ë©”ë¼ / ìš°: íŒ¨ë„(ë¹¨ê°„ì–¼êµ´+í‘œ) */
    .wrap {
      display: flex; gap: 24px;
      align-items: flex-start; justify-content: center;
      padding: 24px;
    }

    /* ì™¼ìª½ ì‹¤ì œ ì¹´ë©”ë¼ */
    .camCol {
      display: flex; flex-direction: column; gap: 12px;
    }
    #cam {
      display: block;
      width: 640px; height: 480px;         /* í•„ìš”í•˜ë©´ í¬ê¸° ì¡°ì ˆ */
      background: #111; border: 1px solid #222; border-radius: 12px;
      object-fit: cover;
      transform: scaleX(-1);               /* ê±°ìš¸ ëª¨ë“œ(ì›ì¹˜ ì•Šìœ¼ë©´ ì œê±°) */
    }

    /* ì˜¤ë¥¸ìª½ íŒ¨ë„ */
    .panel {
      width: 360px; background: #111; border: 1px solid #222; border-radius: 12px;
      padding: 14px 14px 18px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
      display: flex; flex-direction: column; gap: 12px; align-items: center;
    }

    /* ğŸ”´ ë¯¸ë‹ˆ ì–¼êµ´(ì¡°ê¸ˆ ì‘ê²Œ) */
    #miniFace {
      width: 220px; height: 220px;         /* â–¶ï¸ ì´ì „ë³´ë‹¤ ì‚´ì§ ì¶•ì†Œ */
      background: #111; border: 1px solid #222; border-radius: 12px; display: block;
    }

    .state-badge { font-weight: 700; }
    table { width: 100%; border-collapse: collapse; font-variant-numeric: tabular-nums; }
    th, td { border: 1px solid #2a2a2a; padding: 8px; text-align: center; }
    th { background: #171717; } td { background: #121212; }
    .reasons { font-size: 12px; color: #cfcfcf; white-space: pre-wrap; width: 100%; }
    .fm-hidden { position: fixed !important; left: -9999px !important; top: -9999px !important; }
  </style>
</head>
<body>
    <h1 style="text-align:center; margin-top:20px; color:#fff; font-size:28px;"> <!--ì œëª©-->
      FocusMate 
    </h1>
   
  <div class="wrap">
    <!-- â¬…ï¸ ì™¼ìª½: ì‹¤ì œ ì¹´ë©”ë¼ -->
    <div class="camCol">
      <!-- ì—¬ê¸° ìë¦¬ëŠ” dev.tsì—ì„œ vision.videoë¡œ êµì²´ë¨ -->
      <video id="cam" width="320" height="240" autoplay playsinline muted></video>
    </div>

    <!-- â¡ï¸ ì˜¤ë¥¸ìª½: ë¹¨ê°„ ì–¼êµ´ + í‘œ -->
    <div class="panel">
      <!-- ğŸ”´ ë¯¸ë‹ˆ ì–¼êµ´(ì¶•ì†Œ) -->
      <canvas id="miniFace" width="220" height="220"></canvas>

      <div class="state-badge">
        <span id="state">STATE â€”</span>
        <span id="score" style="opacity:.8;margin-left:6px">score â€”</span>
      </div>

      <table>
        <thead><tr><th>í•­ëª©</th><th>ê°’</th></tr></thead>
        <tbody>
          <tr><td>EAR</td><td id="ear">â€”</td></tr>
          <tr><td>PERCLOS</td><td id="perclos">â€”</td></tr>
          <tr><td>Fixation</td><td id="fix">â€”</td></tr>
          <tr><td>Dwell</td><td id="dwell">â€”</td></tr>
          <tr><td>ROI</td><td id="roi">â€”</td></tr>
        </tbody>
      </table>

      <div class="reasons" id="reasons"></div>
    </div>
  </div>

  <!-- íŒŒì´í”„ë¼ì¸ ê³„ì‚° ë¡œë“œ -->
  <script type="module" src="/src/dev.ts"></script>

  <!-- ì–¼êµ´ ê·¸ë¦¬ê¸° & í‘œ ê°±ì‹  -->
  <script>
    const mini = document.getElementById('miniFace');
    const mctx = mini.getContext('2d');

    /* Mediapipe FaceMesh ëŒ€í‘œ ì»¨íˆ¬ì–´ ì¸ë±ìŠ¤ */
    const OVAL        = [10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109,10];
    const RIGHT_BROW  = [70,63,105,66,107,55];
    const LEFT_BROW   = [336,296,334,293,300,276];
    const RIGHT_EYE   = [33,7,163,144,145,153,154,155,133,173,157,158,159,160,161,246,33];
    const LEFT_EYE    = [362,382,381,380,374,373,390,249,263,466,388,387,386,385,384,398,362];
    const OUTER_LIPS  = [61,146,91,181,84,17,314,405,321,375,291,308,324,318,402,317,14,87,178,88,95,78,61];
    const INNER_LIPS  = [78,95,88,178,87,14,317,402,318,324,308,291,375,321,405,314,17,84,181,91,146,61];
    const NOSE_BRIDGE = [168,6,197,195,5,4];
    const NOSE_TIP    = [1,2,98,327,168];

    function drawPath(P, idxs, closed=false){
      if (!idxs.length) return;
      mctx.beginPath();
      for (let i=0; i<idxs.length; i++){
        const [x,y] = P[idxs[i]];
        if (i===0) mctx.moveTo(x,y); else mctx.lineTo(x,y);
      }
      if (closed) mctx.closePath();
      mctx.stroke();
    }

    function drawMiniFace(detail) {
      const lm = detail?.landmarks;
      const w = mini.width, h = mini.height;

      if (!Array.isArray(lm) || lm.length < 100) {
        // í´ë°±: ëˆˆë§Œ ì ìœ¼ë¡œ
        const eyes = [...(detail?.eyes?.l ?? []), ...(detail?.eyes?.r ?? [])];
        if (!eyes.length) return;
        const xs = eyes.map(p=>p[0]), ys = eyes.map(p=>p[1]);
        const cx = xs.reduce((a,b)=>a+b,0)/xs.length, cy = ys.reduce((a,b)=>a+b,0)/ys.length;
        const rangeX = Math.max(...xs)-Math.min(...xs);
        const rangeY = Math.max(...ys)-Math.min(...ys);
        const scale = 0.9 / Math.max(rangeX, rangeY || 1e-6);
        mctx.clearRect(0,0,w,h);
        mctx.fillStyle='rgba(255,0,0,0.9)';
        for (const [x,y] of eyes) {
          const px = w/2 + (x-cx)*w*scale, py = h/2 + (y-cy)*h*scale;
          mctx.beginPath(); mctx.arc(px,py,2,0,Math.PI*2); mctx.fill();
        }
        if (detail?.iris?.l && detail?.iris?.r) {
          mctx.fillStyle='orange';
          for (const c of [detail.iris.l, detail.iris.r]) {
            const px = w/2 + (c[0]-cx)*w*scale, py = h/2 + (c[1]-cy)*h*scale;
            mctx.beginPath(); mctx.arc(px,py,3,0,Math.PI*2); mctx.fill();
          }
        }
        return;
      }

      // ì „ì²´ ì–¼êµ´(468) â†’ ì¤‘ì•™ ë°°ì¹˜ ìŠ¤ì¼€ì¼
      const xs = lm.map(p=>p[0]), ys = lm.map(p=>p[1]);
      const cx = xs.reduce((a,b)=>a+b,0)/xs.length, cy = ys.reduce((a,b)=>a+b,0)/ys.length;
      const rangeX = Math.max(...xs)-Math.min(...xs);
      const rangeY = Math.max(...ys)-Math.min(...ys);
      const scale = 0.95 / Math.max(rangeX, rangeY || 1e-6);

      const P = lm.map(([x,y]) => [
        w/2 + (x-cx)*w*scale,
        h/2 + (y-cy)*h*scale
      ]);

      mctx.clearRect(0,0,w,h);

      // ì„ (ì»¨íˆ¬ì–´)
      mctx.strokeStyle = 'rgba(255,0,0,0.65)';
      mctx.lineWidth = 1.1;
      drawPath(P, OVAL, true);
      drawPath(P, RIGHT_BROW);  drawPath(P, LEFT_BROW);
      drawPath(P, RIGHT_EYE, true); drawPath(P, LEFT_EYE, true);
      drawPath(P, OUTER_LIPS, true); drawPath(P, INNER_LIPS, true);
      drawPath(P, NOSE_BRIDGE); drawPath(P, NOSE_TIP);

      // ì (ì „ì²´ ëœë“œë§ˆí¬)
      mctx.fillStyle = 'rgba(255,0,0,0.9)';
      for (const [px,py] of P) { mctx.beginPath(); mctx.arc(px,py,1.5,0,Math.PI*2); mctx.fill(); }

      // í™ì±„
      if (detail?.iris?.l && detail?.iris?.r) {
        mctx.fillStyle='orange';
        for (const c of [detail.iris.l, detail.iris.r]) {
          const px = w/2 + (c[0]-cx)*w*scale, py = h/2 + (c[1]-cy)*h*scale;
          mctx.beginPath(); mctx.arc(px,py,3,0,Math.PI*2); mctx.fill();
        }
      }
    }

    // ì´ë²¤íŠ¸ ì—°ê²°
    window.addEventListener('fm:vision',  e => drawMiniFace(e.detail));

    // í‘œ ê°±ì‹ 
    const $ = id => document.getElementById(id);
    window.addEventListener('fm:metrics', e => {
      const m = e.detail;
      $('ear').textContent      = m.earAvg?.toFixed(3);
      $('perclos').textContent  = (m.perclos * 100).toFixed(1) + '%';
      $('fix').textContent      = m.fixation?.isFixed ? 'Fixed' : 'Not fixed';
      $('dwell').textContent    = Math.round(m.fixation?.dwellMs || 0) + ' ms';
      $('roi').textContent      = m.fixation?.roiKey || '-';
    });
    window.addEventListener('fm:state', e => {
      const s = e.detail;
      if (s?.state) $('state').textContent = 'STATE ' + s.state;
      if (typeof s?.score === 'number') $('score').textContent = 'score ' + s.score;
      if (s?.reason)
        $('reasons').textContent = Array.isArray(s.reason) ? s.reason.join('\n') : String(s.reason);
    });

    // dev.ts ë””ë²„ê·¸ íŒ¨ë„ ìˆ¨ê¹€
    const hideDevPanel = () => {
      const p = [...document.querySelectorAll('div')]
        .find(d => d.textContent?.includes('STATE:') && getComputedStyle(d).position === 'fixed');
      if (p) p.classList.add('fm-hidden'); else setTimeout(hideDevPanel, 500);
    };
    hideDevPanel();
  </script>
</body>
</html>
